summary(f1)
coef(f1)
f1 <- lm(y~x)
plot(x, y)
abline(f1)
summary(f1)
coef(f1)
k11 <- sum(x^2)
k12 <- sum(x)
b1  <- sum(x * y)
k21 <- sum(x)
k22 <- length(x)
b2  <- sum(y)
m1 <- matrix(c(k11, k12,
k21, k22), ncol=2, byrow=T)
det_m1 <- det(m1)
m1_a = matrix(c(b1, k12,
b2, k22), ncol=2,  byrow=T)
m1_b = matrix(c(k11, b1,
k21, b2), ncol=2, byrow=T)
det_a = det(m1_a)
det_b = det(m1_b)
a = det_a/det_m1
b = det_b/det_m1
a_accurate <- coef(f1)[2]
b_accurate <- coef(f1)[1]
a_abs_err <- abs(a_accurate - a)
b_abs_err <- abs(b_accurate - b)
a_rel_err <- a_abs_err / abs(a_accurate)
b_rel_err <- b_abs_err / abs(b_accurate)
count <- 1
plot(x, y)
abline(a=b, b=a, col='red')
plot(x, y)
abline(a=b, b=a, col='red')
f2 <- lm(y~x + I(x^2))
f2
f2 <- lm(y~x + I(x^2))
f2 <- lm(y~x + I(x^2))
f2 <- lm(y~x + I(x^2))
f2 <- lm(y~x + I(x^2))
clear_all <- function() {
rm(list=ls())
graphics.off()
cat("\014")
}
rm(list=ls())
graphics.off()
cat("\014")
# вар 1
x <- c(1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.044)  + rnorm(10, 0, 0.0001)
y <- c(1.538, 1.406, 1.538, 1.406, 1.538, 1.406, 1.406, 1.538, 1.406)  + rnorm(10, 0, 0.0001)
k11 <- sum(x^2)
k12 <- sum(x)
b1  <- sum(x * y)
k21 <- sum(x)
k22 <- length(x)
b2  <- sum(y)
m1 <- matrix(c(k11, k12,
k21, k22), ncol=2, nrow=2)
det_m1 <- det(m1)
m1_a = matrix(c(b1, k12,
b2, k22), ncol=2, nrow=2)
m1_b = matrix(c(k11, b1,
k21, b2), ncol=2, nrow=2)
det_a = det(m1_a)
det_b = det(m1_b)
#det1 <- b1*k22 - k12*b2
#det2 <- k11*b2 - b1*k21
a = det_a/det_m1
b = det_b/det_m1
plot(x, y)
f1 <- lm(y~x)
abline(f1)
abline(a = b, b = a, col='red')
summary(f1)
coef(f1)
a_accurate <- coef(f1)[2]
b_accurate <- coef(f1)[1]
a_abs_err <- abs(a_accurate - a)
b_abs_err <- abs(b_accurate - b)
a_rel_err <- a_abs_err / abs(a_accurate)
b_rel_err <- b_abs_err / abs(b_accurate)
# c тремя
rm(list=ls())
x <- c(1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.044)  + rnorm(10, 0, 0.0001)
y <- c(1.538, 1.406, 1.538, 1.406, 1.538, 1.406, 1.406, 1.538, 1.406)  + rnorm(10, 0, 0.0001)
f2 <- lm(y~x + I(x^2))
f2
?I
summary(f2)
summary(f2)
coef(f2)
x <- c(1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.044) # + rnorm(10, 0, 0.0001)
y <- c(1.538, 1.406, 1.538, 1.406, 1.538, 1.406, 1.406, 1.538, 1.406)  #+ rnorm(10, 0, 0.0001)
clear_all <- function() {
rm(list=ls())
graphics.off()
cat("\014")
}
f1 <- lm(y~x)
plot(x, y)
abline(f1)
summary(f1)
coef(f1)
k11 <- sum(x^2)
k12 <- sum(x)
b1  <- sum(x * y)
k21 <- sum(x)
k22 <- length(x)
b2  <- sum(y)
m1 <- matrix(c(k11, k12,
k21, k22), ncol=2, byrow=T)
det_m1 <- det(m1)
m1_a = matrix(c(b1, k12,
b2, k22), ncol=2,  byrow=T)
m1_b = matrix(c(k11, b1,
k21, b2), ncol=2, byrow=T)
det_a = det(m1_a)
det_b = det(m1_b)
a = det_a/det_m1
b = det_b/det_m1
a_accurate <- coef(f1)[2]
b_accurate <- coef(f1)[1]
a_abs_err <- abs(a_accurate - a)
b_abs_err <- abs(b_accurate - b)
a_rel_err <- a_abs_err / abs(a_accurate)
b_rel_err <- b_abs_err / abs(b_accurate)
count <- 1
plot(x, y)
abline(a=b, b=a, col='red')
f2 <- lm(y~x + I(x^2))
xi <- seq(1, 2, 0.01)
yi <- predict(f2, data.frame(x=xi))
plot(x, y)
lines(xi,yi)
summary(f2)
coef(f2)
k11 <- sum(x^2)
k12 <- sum(x)
k13 <- length(x)
b1  <- sum(y)
k21 <- sum(x^3)
k22 <- sum(x^2)
k23 <- sum(x)
b2  <- sum(x*y)
k31 <- sum(x^4)
k32 <- sum(x^3)
k33 <- sum(x^2)
b3  <- sum(x^2 * y)
m2    <- matrix(c(k11, k12, k13,
k21, k22, k23,
k31, k32, k33), ncol=3, nrow=3, byrow=T)
m2_a0 <- matrix(c(b1, k12, k13,
b2, k22, k23,
b3, k32, k33), ncol=3, nrow=3, byrow=T)
m2_a1 <- matrix(c(k11, b1, k13,
k21, b2, k23,
k31, b3, k33), ncol=3, nrow=3, byrow=T)
m2_a2 <- matrix(c(k11, k12, b1,
k21, k22, b2,
k31, k32, b3), ncol=3, nrow=3, byrow=T)
det_m2 <- det(m2)
det_a0 <- det(m2_a0)
det_a1 <- det(m2_a1)
det_a2 <- det(m2_a2)
a0 <- det_a0 / det_m2
a1 <- det_a1 / det_m2
a2 <- det_a2 / det_m2
a0_accurate <- coef(f2)[3]
a1_accurate <- coef(f2)[2]
a2_accurate <- coef(f2)[1]
a0_abs_err = abs(a0_accurate - a0)
a1_abs_err = abs(a1_accurate - a1)
a2_abs_err = abs(a2_accurate - a2)
a0_rel_err = a0_abs_err / abs(a0)
a1_rel_err = a1_abs_err / abs(a1)
a2_rel_err = a2_abs_err / abs(a2)
f <- function(x) {
a2 + a1 * x + a0 * x^2
}
new_yi <- f(xi)
plot(x, y)
lines(xi, new_yi)
f2
?I
I(x^2)
x + I(x^2)
x + x^2
lm(y~x)
z
z <- lm(y~x)
z
f2 <- lm(y~x + I(x^2))
f2
---
format:
html:
self-contained: true
```{r echo=F,  fig.cap="Полученный график линейной апроксимирующей функции"}
x <- c(1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.577, 1.044, 1.044) # + rnorm(10, 0, 0.0001)
y <- c(1.538, 1.406, 1.538, 1.406, 1.538, 1.406, 1.406, 1.538, 1.406)  #+ rnorm(10, 0, 0.0001)
clear_all <- function() {
rm(list=ls())
graphics.off()
cat("\014")
}
f1 <- lm(y~x)
plot(x, y)
abline(f1)
summary(f1)
coef(f1)
k11 <- sum(x^2)
k12 <- sum(x)
b1  <- sum(x * y)
k21 <- sum(x)
k22 <- length(x)
b2  <- sum(y)
m1 <- matrix(c(k11, k12,
k21, k22), ncol=2, byrow=T)
det_m1 <- det(m1)
m1_a = matrix(c(b1, k12,
b2, k22), ncol=2,  byrow=T)
m1_b = matrix(c(k11, b1,
k21, b2), ncol=2, byrow=T)
det_a = det(m1_a)
det_b = det(m1_b)
a = det_a/det_m1
b = det_b/det_m1
a_accurate <- coef(f1)[2]
b_accurate <- coef(f1)[1]
a_abs_err <- abs(a_accurate - a)
b_abs_err <- abs(b_accurate - b)
a_rel_err <- a_abs_err / abs(a_accurate)
b_rel_err <- b_abs_err / abs(b_accurate)
count <- 1
#| label: fig-aprox
#| fig-cap: Полученный график линейной апроксимирующей функции
plot(x, y)
abline(a=b, b=a, col='red')
f2 <- lm(y~x + I(x^2))
xi <- seq(1, 2, 0.01)
yi <- predict(f2, data.frame(x=xi))
plot(x, y)
lines(xi,yi)
summary(f2)
coef(f2)
k11 <- sum(x^2)
k12 <- sum(x)
k13 <- length(x)
b1  <- sum(y)
k21 <- sum(x^3)
k22 <- sum(x^2)
k23 <- sum(x)
b2  <- sum(x*y)
k31 <- sum(x^4)
k32 <- sum(x^3)
k33 <- sum(x^2)
b3  <- sum(x^2 * y)
m2    <- matrix(c(k11, k12, k13,
k21, k22, k23,
k31, k32, k33), ncol=3, nrow=3, byrow=T)
m2_a0 <- matrix(c(b1, k12, k13,
b2, k22, k23,
b3, k32, k33), ncol=3, nrow=3, byrow=T)
m2_a1 <- matrix(c(k11, b1, k13,
k21, b2, k23,
k31, b3, k33), ncol=3, nrow=3, byrow=T)
m2_a2 <- matrix(c(k11, k12, b1,
k21, k22, b2,
k31, k32, b3), ncol=3, nrow=3, byrow=T)
det_m2 <- det(m2)
det_a0 <- det(m2_a0)
det_a1 <- det(m2_a1)
det_a2 <- det(m2_a2)
a0 <- det_a0 / det_m2
a1 <- det_a1 / det_m2
a2 <- det_a2 / det_m2
a0_accurate <- coef(f2)[3]
a1_accurate <- coef(f2)[2]
a2_accurate <- coef(f2)[1]
a0_abs_err = abs(a0_accurate - a0)
a1_abs_err = abs(a1_accurate - a1)
a2_abs_err = abs(a2_accurate - a2)
a0_rel_err = a0_abs_err / abs(a0)
a1_rel_err = a1_abs_err / abs(a1)
a2_rel_err = a2_abs_err / abs(a2)
f <- function(x) {
a2 + a1 * x + a0 * x^2
}
new_yi <- f(xi)
plot(x, y)
lines(xi, new_yi)
#| label: fig-lin-approx-my
#| fig-cap: График полученной линейной апроксимирующей функции
xi = seq(0, 3, 0.1)
yi = a*xi + b
plot(x, y)
legend("topleft", legend=expression(y~'='~a*x + b), lty=1)
lines(xi, yi)
x <- c(0.525, 0.730, 0.934, 1.139, 1.344, 1.549, 1.753, 1.958, 2.163, 2.368)
y <- c(0.360, 0.426, 0.483, 0.561, 0.610, 0.645, 0.710, 0.737, 0.736, 0.773)
#| label: fig-lin-aprox-builtin
#| fig-cap: График встроенной линейной апроксимирующей функции
f1 <- lm(y~x)
plot(x, y)
abline(f1, col="blue", lty=2)
legend("topleft", legend=expression(lm(y~'~'~x)), lty=2, lwd=1, col="blue")
summary(f1)
coef(f1)
determinant <- function(matrix) {
if (ncol(matrix) == nrow(matrix)) {
if (ncol(matrix) == 1) {
return(matrix[1, 1])
} else if (ncol(matrix) == 2) {
result <- (matrix[1, 1] * matrix[2, 2]) - (matrix[1, 2] * matrix[2, 1])
return(result)
} else {
det <- 0
for (i in 1:ncol(matrix)) {
sign <- (-1)^(i+1)
minor <- matrix[-1, -i]
det <- det + sign * matrix[1, i] * determinant(minor)
}
return(det)
}
} else {
return("Error: Input matrix is not square")
}
}
k11 <- sum(x^2)
k12 <- sum(x)
b1  <- sum(x * y)
k21 <- sum(x)
k22 <- length(x)
b2  <- sum(y)
m1 <- matrix(c(k11, k12,
k21, k22), ncol=2, byrow=T)
m1_a = matrix(c(b1, k12,
b2, k22), ncol=2, byrow=T)
m1_b = matrix(c(k11, b1,
k21, b2), ncol=2, byrow=T)
det_m1 <- determinant(m1)
det_a = determinant(m1_a)
det_b = determinant(m1_b)
a = det_a / det_m1
b = det_b / det_m1
a_accurate <- coef(f1)[2]
b_accurate <- coef(f1)[1]
a_abs_err <- abs(a_accurate - a)
b_abs_err <- abs(b_accurate - b)
a_rel_err <- a_abs_err / abs(a_accurate)
b_rel_err <- b_abs_err / abs(b_accurate)
#| label: fig-lin-approx-my
#| fig-cap: График полученной линейной апроксимирующей функции
xi = seq(0, 3, 0.1)
yi = a*xi + b
plot(x, y)
legend("topleft", legend=expression(y~'='~a*x + b), lty=1)
lines(xi, yi)
as_accurate <- c(0.120, 0.486, -0.090)
f2 <- lm(y~x + I(x^2))
xi <- seq(0, 3, 0.01)
yi <- predict(f2, data.frame(x=xi))
yi_accurate <- as_accurate[1] + as_accurate[2]*xi + as_accurate[3]*xi^2
plot(x, y)
lines(xi,yi)
lines(xi, yi_accurate, col="blue", lty=2)
legend("topleft", legend=expression(lm(y~'~'~x + I(x^2))), lty=2, lwd=1, col="blue")
c(1,2)
c(expressing(1))
c(expression(1))
c(expression(1), expression(2 + 3))
#| label: fig-square-approx-defined
#| fig-cap: График квадратичной апроксимирующей функции с точными коэффициентами
plot(x, y)
lines(xi,yi)
lines(xi, yi_accurate, col="blue", lty=2)
legend("topleft", legend=с
expression(lm(y~'~'~x + I(x^2))),
#| label: fig-square-approx-defined
#| fig-cap: График квадратичной апроксимирующей функции с точными коэффициентами
plot(x, y)
c =c
lines(xi,yi)
lines(xi, yi_accurate, col="blue", lty=2)
legend("topleft", legend=с(
expression(lm(y~'~'~x + I(x^2))),
expression(y~'='~a[0] + a[1]*x + a[2]*x^2)
), lty=c(2, 2), lwd=1, col=c("blue", "lightblue"))
View(c)
x <- c(0.525, 0.730, 0.934, 1.139, 1.344, 1.549, 1.753, 1.958, 2.163, 2.368)
y <- c(0.360, 0.426, 0.483, 0.561, 0.610, 0.645, 0.710, 0.737, 0.736, 0.773)
#| label: fig-lin-aprox-builtin
#| fig-cap: График встроенной линейной апроксимирующей функции
f1 <- lm(y~x)
plot(x, y)
abline(f1, col="blue", lty=2)
legend("topleft", legend=expression(lm(y~'~'~x)), lty=2, lwd=1, col="blue")
summary(f1)
coef(f1)
determinant <- function(matrix) {
if (ncol(matrix) == nrow(matrix)) {
if (ncol(matrix) == 1) {
return(matrix[1, 1])
} else if (ncol(matrix) == 2) {
result <- (matrix[1, 1] * matrix[2, 2]) - (matrix[1, 2] * matrix[2, 1])
return(result)
} else {
det <- 0
for (i in 1:ncol(matrix)) {
sign <- (-1)^(i+1)
minor <- matrix[-1, -i]
det <- det + sign * matrix[1, i] * determinant(minor)
}
return(det)
}
} else {
return("Error: Input matrix is not square")
}
}
k11 <- sum(x^2)
k12 <- sum(x)
b1  <- sum(x * y)
k21 <- sum(x)
k22 <- length(x)
b2  <- sum(y)
m1 <- matrix(c(k11, k12,
k21, k22), ncol=2, byrow=T)
m1_a = matrix(c(b1, k12,
b2, k22), ncol=2, byrow=T)
m1_b = matrix(c(k11, b1,
k21, b2), ncol=2, byrow=T)
det_m1 <- determinant(m1)
det_a = determinant(m1_a)
det_b = determinant(m1_b)
a = det_a / det_m1
b = det_b / det_m1
a_accurate <- coef(f1)[2]
b_accurate <- coef(f1)[1]
a_abs_err <- abs(a_accurate - a)
b_abs_err <- abs(b_accurate - b)
a_rel_err <- a_abs_err / abs(a_accurate)
b_rel_err <- b_abs_err / abs(b_accurate)
#| label: fig-lin-approx-my
#| fig-cap: График полученной линейной апроксимирующей функции
xi = seq(0, 3, 0.1)
yi = a*xi + b
plot(x, y)
legend("topleft", legend=expression(y~'='~a*x + b), lty=1)
lines(xi, yi)
as_accurate <- c(0.120, 0.486, -0.090)
f2 <- lm(y~x + I(x^2))
xi <- seq(0, 3, 0.01)
yi <- predict(f2, data.frame(x=xi))
yi_accurate <- as_accurate[1] + as_accurate[2]*xi + as_accurate[3]*xi^2
#| label: fig-square-approx-defined
#| fig-cap: График квадратичной апроксимирующей функции с точными коэффициентами
plot(x, y)
c =c
lines(xi,yi)
lines(xi, yi_accurate, col="blue", lty=2)
legend("topleft", legend=с(
expression(lm(y~'~'~x + I(x^2))),
expression(y~'='~a[0] + a[1]*x + a[2]*x^2)
), lty=c(2, 2), lwd=1, col=c("blue", "lightblue"))
#| label: fig-square-approx-defined
#| fig-cap: График квадратичной апроксимирующей функции с точными коэффициентами
plot(x, y)
lines(xi,yi)
lines(xi, yi_accurate, col="blue", lty=2)
legend("topleft", legend=с(expression(lm(y~'~'~x + I(x^2))),expression(y~'='~a[0] + a[1]*x + a[2]*x^2)), lty=c(2, 2), lwd=1, col=c("blue", "lightblue"))
?legend
#| label: fig-square-approx-defined
#| fig-cap: График квадратичной апроксимирующей функции с точными коэффициентами
plot(x, y)
lines(xi,yi)
lines(xi, yi_accurate, col="blue", lty=2)
legend("topleft", legend=list(expression(lm(y~'~'~x + I(x^2))),expression(y~'='~a[0] + a[1]*x + a[2]*x^2)), lty=c(2, 2), lwd=1, col=c("blue", "lightblue"))
#| label: fig-square-approx-defined
#| fig-cap: График квадратичной апроксимирующей функции с точными коэффициентами
plot(x, y)
lines(xi,yi)
lines(xi, yi_accurate, col="blue", lty=2)
legend("topleft", legend=c(list(expression(lm(y~'~'~x + I(x^2))),expression(y~'='~a[0] + a[1]*x + a[2]*x^2))), lty=c(2, 2), lwd=1, col=c("blue", "lightblue"))
grep(colors(), "blue")
grep(colors(), "blue")
colors()
?grep
grep("blue", colors())
grep("blue", colors())
grep("blue", colors())
colors(grep("blue", colors()))
colors(grep("blue", colors()))
colors[grep("blue", colors())]
colors
colors()
#| label: fig-square-approx-my
#| fig-cap: График полученной квадратичной апроксимирующей функции
plot(x, y)
lines(xi, yi)
legend("topleft", legend=expression(y~'='~a[0] + a[1]*x + a[2]*x^2), lty=1)
#| label: fig-square-approx-defined
#| fig-cap: График встроенной квадратичной апроксимирующей функции
plot(x, y)
lines(xi, yi_accurate, col="cyan")
lines(xi, yi, col="blue", lty=2)
legend("topleft", legend=c(
expression(y~'='~alpha[0] + alpha[1]*x + alpha[2]*x^2)),
expression(lm(y~'~'~x + I(x^2))),
lty=c(2, 1), lwd=1, col=c("cyan", "blue")
)
